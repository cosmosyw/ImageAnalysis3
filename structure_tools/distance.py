import numpy as np
import multiprocessing as mp
import time
import pandas as pd
# functions
from itertools import combinations_with_replacement, combinations
from scipy.spatial.distance import pdist, squareform, cdist
from tqdm import tqdm
# shared parameters
default_num_threads = 12

def Chr2ZxysList_2_ChrDistDict(chr_2_zxys_list, ):
    _chrs = list(chr_2_zxys_list.keys())
    _chr_dist_dict = {}
    for _c1, _c2 in combinations_with_replacement(_chrs, 2):
        # if not from the same chr label, calcluate trans-chr with cdist
        if _c1 != _c2:
            _chr_dist_dict[(_c1,_c2)] = []
            for _zxys1 in chr_2_zxys_list[_c1]:
                for _zxys2 in chr_2_zxys_list[_c2]:
                    _chr_dist_dict[(_c1,_c2)].append(cdist(_zxys1, _zxys2))
        # if from the same chr label, calculate both cis and trans
        else:
            # cis
            _chr_dist_dict[f"cis_{_c1}"] = [squareform(pdist(_zxys)) for _zxys in chr_2_zxys_list[_c1]]
            # trans
            if len(chr_2_zxys_list[_c1]) > 1:
                _chr_dist_dict[f"trans_{_c1}"] = []
                # loop through combinations
                for _i1, _i2 in combinations(np.arange(len(chr_2_zxys_list[_c1])), 2):
                    _chr_dist_dict[f"trans_{_c1}"].append(
                        cdist(chr_2_zxys_list[_c1][_i1], chr_2_zxys_list[_c1][_i2])
                    )
    return _chr_dist_dict

def summarize_ChrDistDicts(dist_dict_list, codebook_df,
                           function='nanmedian', axis=0, 
                           verbose=False):
    """Function to summarize list of ChrDistDict, generated by Chr2ZxysList_2_ChrDistDict"""
    all_chrs = [str(_chr) for _chr in np.unique(codebook_df['chr'])]
    all_chr_sizes = {_chr:np.sum(codebook_df['chr']==_chr) for _chr in all_chrs}
    # generate all possible keys
    summary_dist_dict = {}
    for _c1, _c2 in combinations_with_replacement(all_chrs, 2):
        # if not from the same chr label, calcluate trans-chr with cdist
        if _c1 != _c2:
            summary_dist_dict[(_c1,_c2)] = []
        else:
            summary_dist_dict[f"cis_{_c1}"] = []
            summary_dist_dict[f"trans_{_c1}"] = []
    for _key in tqdm(summary_dist_dict.keys()):
        if verbose:
            print(_key)
        for _dist_dict in dist_dict_list:
            if _key in _dist_dict:
                summary_dist_dict[_key].extend(_dist_dict[_key])
        if len(summary_dist_dict[_key]) > 0:
            # summarize
            summary_dist_dict[_key] = getattr(np, function)(summary_dist_dict[_key], axis=axis)
        else:
            if isinstance(_key, str): # cis or trans
                _chr = _key.split('_')[-1] 
                summary_dist_dict[_key]= np.nan * np.ones([all_chr_sizes[_chr], all_chr_sizes[_chr]])
            else:
                _chr1, _chr2 = _key
                summary_dist_dict[_key]= np.nan * np.ones([all_chr_sizes[_chr1], all_chr_sizes[_chr2]])
                
    return summary_dist_dict
    
def assemble_ChrDistDict_2_Matrix(dist_dict, codebook_df, use_cis=True):
    """Assemble a dist_dict into distance matrix shape"""
    _matrix = np.ones([len(codebook_df),len(codebook_df)]) * np.nan
    _ordered_chr_names = []
    for _chr_name, _chr_reg_id in zip(codebook_df['chr'], codebook_df['chr_order']):
        if _chr_name not in _ordered_chr_names:
            _ordered_chr_names.append(_chr_name)
    chr_2_indices = {str(_chr):np.array(codebook_df.loc[codebook_df['chr']==_chr].index)
                    for _chr in np.unique(codebook_df['chr'].values)}
    for _chr1, _ind1 in chr_2_indices.items():
        for _chr2, _ind2 in chr_2_indices.items():
            if _chr1 == _chr2:
                if use_cis and f"cis_{_chr1}" in dist_dict:
                    _matrix[_ind1[:, np.newaxis], _ind2] = dist_dict[f"cis_{_chr1}"]
                elif not use_cis and f"trans_{_chr1}" in dist_dict:
                    _matrix[_ind1[:, np.newaxis], _ind2] = dist_dict[f"trans_{_chr1}"]
            else:
                if (_chr1, _chr2) in dist_dict:
                    _matrix[_ind1[:, np.newaxis], _ind2] = dist_dict[(_chr1, _chr2)]
                    _matrix[_ind2[:, np.newaxis], _ind1] = dist_dict[(_chr1, _chr2)].transpose()
                elif (_chr2, _chr1) in dist_dict:
                    _matrix[_ind1[:, np.newaxis], _ind2] = dist_dict[(_chr2, _chr1)].transpose()
                    _matrix[_ind2[:, np.newaxis], _ind1] = dist_dict[(_chr2, _chr1)]
    return _matrix

def batch_convert_Chr2ZxysList(
    chr_2_zxys_list:list,
    codebook_df:pd.DataFrame,
    function='nanmedian', 
    axis=0, 
    ):
    print(f"- Batch process {len(chr_2_zxys_list)} chr_2_zxys dicts")
    _dist_dicts = [Chr2ZxysList_2_ChrDistDict(_chr_zxys) for _chr_zxys in tqdm(chr_2_zxys_list)]
    summary_dist_dict = summarize_ChrDistDicts(
        _dist_dicts, codebook_df=codebook_df,
        function=function,axis=axis,
        )
    return summary_dist_dict



def Chr2ZxysList_2_ChrDistDict(chr_2_zxys_list, ):
    _chrs = list(chr_2_zxys_list.keys())
    _chr_dist_dict = {}
    for _c1, _c2 in combinations_with_replacement(_chrs, 2):
        # if not from the same chr label, calcluate trans-chr with cdist
        if _c1 != _c2:
            _chr_dist_dict[(_c1,_c2)] = []
            for _zxys1 in chr_2_zxys_list[_c1]:
                for _zxys2 in chr_2_zxys_list[_c2]:
                    _chr_dist_dict[(_c1,_c2)].append(cdist(_zxys1, _zxys2))
        # if from the same chr label, calculate both cis and trans
        else:
            # cis
            _chr_dist_dict[f"cis_{_c1}"] = [squareform(pdist(_zxys)) for _zxys in chr_2_zxys_list[_c1]]
            # trans
            if len(chr_2_zxys_list[_c1]) > 1:
                _chr_dist_dict[f"trans_{_c1}"] = []
                # loop through combinations
                for _i1, _i2 in combinations(np.arange(len(chr_2_zxys_list[_c1])), 2):
                    _chr_dist_dict[f"trans_{_c1}"].append(
                        cdist(chr_2_zxys_list[_c1][_i1], chr_2_zxys_list[_c1][_i2])
                    )
    return _chr_dist_dict


def Chr2ZxysList_2_summaryDist(chr_2_zxys_list, _c1, _c2, codebook_df,
                                 function='nanmedian', axis=0, 
                                 verbose=False):
    _out_dist_dict = {}
    if _c1 != _c2:
        _out_dist_dict[(_c1,_c2)] = []
    else:
        _out_dist_dict[f"cis_{_c1}"] = []
        _out_dist_dict[f"trans_{_c1}"] = []
    for _chr_2_zxys in chr_2_zxys_list:
        if _c1 not in _chr_2_zxys or _c2 not in _chr_2_zxys:
            continue
        else:
            
            # if not from the same chr label, calcluate trans-chr with cdist
            if _c1 != _c2:
                for _zxys1 in _chr_2_zxys[_c1]:
                    for _zxys2 in _chr_2_zxys[_c2]:
                        _out_dist_dict[(_c1,_c2)].append(cdist(_zxys1, _zxys2))
            # if from the same chr label, calculate both cis and trans
            else:
                # cis
                _out_dist_dict[f"cis_{_c1}"].extend([squareform(pdist(_zxys)) for _zxys in _chr_2_zxys[_c1]])
                # trans
                if len(_chr_2_zxys[_c1]) > 1:
                    _out_dist_dict[f"trans_{_c1}"] = []
                    # loop through combinations
                    for _i1, _i2 in combinations(np.arange(len(_chr_2_zxys[_c1])), 2):
                        _out_dist_dict[f"trans_{_c1}"].append(
                            cdist(_chr_2_zxys[_c1][_i1], _chr_2_zxys[_c1][_i2])
                        )
    return _out_dist_dict
    # summarize
    _summary_dict = {}
    all_chrs = [str(_chr) for _chr in np.unique(codebook_df['chr'])]
    all_chr_sizes = {_chr:np.sum(codebook_df['chr']==_chr) for _chr in all_chrs}
    for _key, _dists_list in _out_dist_dict.items():
        
        if len(_dists_list) > 0:
            # summarize
            _summary_dict[_key] = getattr(np, function)(_dists_list, axis=axis)
        else:
            if isinstance(_key, str): # cis or trans
                _chr = _key.split('_')[-1] 
                _summary_dict[_key]= np.nan * np.ones([all_chr_sizes[_chr], all_chr_sizes[_chr]])
            else:
                _chr1, _chr2 = _key
                _summary_dict[_key]= np.nan * np.ones([all_chr_sizes[_chr1], all_chr_sizes[_chr2]])
    
    return _summary_dict